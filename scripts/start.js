// Do this as the first thing so that any code reading it knows the right env.
process.env.BABEL_ENV = 'development'
process.env.NODE_ENV = 'development'

/*
    Makes the script crash on unhandled rejections instead of silently
    ignoring them. In the future, promise rejections that are not handled will
    terminate the Node.js process with a non-zero exit code.
 */
process.on('unhandledRejection', (error) => {
    throw error
})

const fs = require('fs')
const webpack = require('webpack')
const WebpackDevServer = require('webpack-dev-server')
const ip = require('ip')
const boxen = require('boxen')
const dedent = require('dedent')
const chalk = require('chalk')
const Table = require('cli-table3')
const QRCode = require('qrcode')

const paths = require('../config/paths')
const devWebpackConfig = require('../config/webpack.config.dev')
const checkComponentLibrary = require('../helper/component-library')
const checkBrowsers = require('../helper/browsers')
const checkRequiredFiles = require('../helper/check-required-files')
const devServerOptions = require('../config/serve.config.js')
const colours = require('../config/colours')

// Apply any local overrides to dev
let appDevServerOptions = {}
const hasAppDevServerConfig = fs.existsSync(paths.appDevServerConfig)

if (hasAppDevServerConfig) {
    appDevServerOptions = require(paths.appDevServerConfig)
}

const combinedDevServerConfig = { ...devServerOptions, ...appDevServerOptions }

// Add the HMR entry points to the webpackConfig.
WebpackDevServer.addDevServerEntrypoints(devWebpackConfig, combinedDevServerConfig)

// Create a webpack compiler that is webpack configured with custom messages.
const compiler = webpack(devWebpackConfig)

// Serve webpack assets generated by the compiler over a web server.
const devServer = new WebpackDevServer(compiler, combinedDevServerConfig)

// Locate HOST/PORT
const PORT = parseInt(process.env.PORT, 10) || 3000
const HOST = process.env.HOST || '0.0.0.0'

const startServer = async () => {
    let fileCheck, browserCheck, componentLibraryCheck

    try {
        fileCheck = await checkRequiredFiles([paths.appIndexHtml, paths.appIndexTsx])
    } catch (e) {
        fileCheck = e.message
    }

    try {
        browserCheck = await checkBrowsers(paths.appPath)
    } catch (e) {
        browserCheck = e.message
    }

    try {
        componentLibraryCheck = await checkComponentLibrary()
    } catch (e) {
        componentLibraryCheck = e.message
    }

    devServer.listen(PORT, HOST, async (err) => {
        if (err) {
            return console.log(err)
        }

        console.log(
            boxen(
                dedent(
                    await generateStartMessage({
                        browserCheck,
                        componentLibraryCheck,
                        fileCheck,
                        hasAppDevServerConfig,
                        host: HOST,
                        ipAddress: ip.address(),
                        port: PORT,
                    })
                ),
                {
                    borderColor: colours.border,
                    padding: 1,
                }
            )
        )
    })
}

const generateStartMessage = async ({
    browserCheck,
    componentLibraryCheck,
    fileCheck,
    hasAppDevServerConfig,
    host,
    ipAddress,
    port,
}) => {
    // This Table is for nicer alignment. Feels like I'm building a website 20 years ago.
    // The chars property removes all the borders.
    const startMessage = new Table({
        colWidths: [4, 100],
        chars: {
            top: '',
            'top-mid': '',
            'top-left': '',
            'top-right': '',
            bottom: '',
            'bottom-mid': '',
            'bottom-left': '',
            'bottom-right': '',
            left: '',
            'left-mid': '',
            mid: '',
            'mid-mid': '',
            right: '',
            'right-mid': '',
            middle: '',
        },
    })

    startMessage.push(['⛑', chalk.hex(colours.heading).bold('Vitalizer by Vital')])
    startMessage.push([])

    startMessage.push(['🗄', chalk.hex(colours.heading).bold('File Check')])
    startMessage.push(['', fileCheck])
    startMessage.push(['', `${chalk.hex(colours.text)('Using local serve.config.dev.js file?')} ${hasAppDevServerConfig ? chalk.hex(colours.info)('Yes') : chalk.hex(colours.error)('No')}`])
    startMessage.push([])

    startMessage.push(['💻', chalk.hex(colours.heading).bold('Browser Support')])
    startMessage.push(['', browserCheck])
    startMessage.push([])

    startMessage.push(['🍔', chalk.hex(colours.heading).bold('Component Library Check')])
    startMessage.push(['', componentLibraryCheck])
    startMessage.push([])

    startMessage.push(['🚀', chalk.hex(colours.heading).bold('Development Web Server')])

    startMessage.push([
        '',
        chalk.hex(colours.text)(
            `You can access this application from a browser on this machine at: http://${host}:${port}`
        ),
    ])

    if (host != 'localhost') {
        startMessage.push([])

        startMessage.push(['', chalk.hex(colours.text)(`From a device on you LAN at: http://${ipAddress}:${port}`)])

        startMessage.push([])

        startMessage.push(['', chalk.hex(colours.text)('Or by using this handy QR Code:')])

        startMessage.push([])

        try {
            startMessage.push(['', await QRCode.toString(`http://${ipAddress}:${PORT}`, { type: 'terminal' })])
        } catch (e) {
            startMessage.push(['', 'Error generating QR code'])
        }
    }

    return startMessage.toString()
}

startServer()
